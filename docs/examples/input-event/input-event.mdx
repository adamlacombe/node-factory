---
name: Input event
route: /examples/input-event
menu: Examples
---

import InputEvent from './InputEvent';
import FormatJson from '../../components/FormatJson';

# Input event

One common thing tested when developing app with [React.js](http://reactjs.org/) is when you type into an
input and you want you component to react to this event. To achieve this, you have to do something like:

```js
it('responds to input change', done => {
  component.find('input#name')
           .simulate('change', { target: { value: 'NEW VALUE' } });

  expect(component.state('data').name).toBe('NEW VALUE');
});
```

So, to simulate a simple change event, we have to constantly describe this event object which has a nested
value (which is actually what usually interests us). So, how can we use `node-factory` to clean this?

## InputEvent factory

One thing we can do to make this event simulation a little cleaner is to define an InputEvent factory. For
simplicity sake, we're gonna keep this simple:

```js
import { factory } from 'node-factory';

const InputEvent = factory(fake => ({
  target: {
    value: fake.random.uuid(),
  }
})).create;

export default InputEvent;
```

<FormatJson parse={() => InputEvent()} />

In this case, the only method that we're interested is the `create` method. That being said, we will only export
this method.

## Changing the value

So, from what we know so far, we now set the event value using our factory:

```js
InputEvent({ target: { value: 'NEW VALUE' } })
```

<FormatJson parse={() => InputEvent({ target: { value: 'NEW VALUE' } })} />

So how does this help us?! It's actually longer now!! Calm down... What you might not know is that `node-factory`
has a shorthand. If you simply pass `{ value: 'NEW VALUE' }` to the create method, it is smart enough to know
that it should update the nested object:

```js
InputEvent({ value: 'NEW VALUE' })
```

<FormatJson parse={() => InputEvent({ value: 'NEW VALUE' })} />

## Updating our test

Now, on our tests we can do:

```js
it('responds to input change', done => {
  component.find('input#name')
           .simulate('change', InputEvent({ value: 'NEW VALUE' }));

  expect(component.state('data').name).toBe('NEW VALUE');
});
```

You can also do this for other events, e.g. Keyboard events (setting a given keyCode), Wheel event, etc., and
have a cleaner and more readable interface to test your components.
