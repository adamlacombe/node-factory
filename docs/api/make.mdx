---
name: make
route: /api/make
menu: API
---

import { Link } from 'docz';
import FormatJson from '../components/FormatJson';
import { UserFactory } from '../components/Factory';

# `Factory.make([count, overrides])`

### args

- `count `<span>`(Number [optional])`</span>: This argument defines how many objects should be generated `(default: 1)`
- `overrides `<Link to="/api/types#idataobject">`(IDataObject [optional])`</Link>: These are value which should be overridden on the generated data `(default: {})`

### return

- `data `<Link to="/api/types#idataobject">`(IDataObject | IDataObject[])`</Link>: A data object or an array containing data objects generated by your generator function

## Description

This method is used to generate data objects withouth persisting to a database. As a rule of thumb, if you're **NOT** testing a database, use the `make` method. Otherwise, use the create method.

## Type

```typescript
interface MakeMethod<T> {
  (): T;
  (overrides: IDataObject): T;
  (count: number): T[];
  (count: number, overrides: IDataObject): T[];
}
```

> Where `T` is the type passed to the factory function.

## Examples

### `(): T`

```js
UserFactory.make()
```

<FormatJson parse={() => UserFactory.make()} />

### `(overrides: IDataObject): T`

```js
UserFactory.make({ name: 'JOHN DOE' })
```

<FormatJson parse={() => UserFactory.make({ name: 'JOHN DOE' })} />

### `(count: number): T[]`

```js
UserFactory.make(1)
```

<FormatJson parse={() => UserFactory.make(1)} />

### `(count: number): T[]`

```js
UserFactory.make(2)
```

<FormatJson parse={() => UserFactory.make(2)} />

### `(count: number, overrides: IDataObject): T[]`

```js
UserFactory.make(2, { name: 'JOHN DOE' })
```

<FormatJson parse={() => UserFactory.make(2, { name: 'JOHN DOE' })} />
